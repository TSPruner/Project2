# Project 2
Consists of 2 files: requirements.txt file which indicates which python packages are required, as well as the application.py file which is the main python flask application. In addition, there are 2 folder that go along with the application: templates which includes all the html files to format and dispaly the website as well as static which includes the css and javascript files needed for the application.

# application.py
File run within flask to start the python application. Includes global definitions for the following: channel messaging object and functions for processing the channel name as well as the message list, which is actually a queue, which appends data to the end of the queue and once the max length of 200 is met, removes the first element from the beginning of the list and shifts everything up so the new element can be appended to the end of the list. Each message in the channel list includes an element for the user name and data information and another for the actual message. 

The class for the channel messaging object includes the following functions: init() which takes the channel passed in and assigns it to the chan variable of the object and an initial empty deque variable with a maxlen of 200 list elements (which is actually a total of 100 messages since each message is 2 elements in the list). isChannel() returns TRUE if the channel passed in is the channel for this object. addMessage() which appends an element to the deque list and returns the updated list. getAllMessages() which returns the all elements in the deque variable as a list. getChan() which returns the channel variable. removeUserMessages() which deletes an element from the deque list at the specified index. isEmpty() which returns TRUE if the deque list contains no elements. There is also an array of channel names, an array of channel messaging objects, app routes for loading html and socketio routes for processing shared data and broadcasting information to updata pages via javascript files. The functions defined are as follows: displayName() Get method which displays layout template where they can enter username to view Flack application channels and messages. 

index() web socketio which passes the channel name to the function so that it can add it to the dictionary as well as the current global channel array and emits the dictionary to 'show data' with broadcast=TRUE. 

channel() web socketio which passes the channel name to the function so that it can first check it to see if it is already in the global channel array and if is, emits an empty list to 'channel names' with broadcast=FALSE, and adds it to the array as well as adds it to the channel messaging objects array with the new channel name. It then emits channels array to 'channel names'with broadcast=TRUE. 

message() web socketio which passes the user name, channel, and message to the function so that it can check to see if there are channels in the channel messaging object array. If so, then for each object in the array, check to see if the channel is in the array and if not, emits an empty list to 'channel messages' with broadcast=FALSE. When channel is found, add the user name and data as an element to the object's deque list as well as the user's message. The channel name, user name, and updated message list are then put in a dictionary which is emitted to 'channel messages' with broadcast=TRUE. 

delete_msgs() web socketio which passes the user name and channel to the function so that it can find all the messages for the given user on the given channel and remove them from the global channel object array. It does this by checking to see if there are channels in the channel messaging object array and if so, then it checks to see if the channel is in the array and when it finds it, it gets all the message elements from the object's deque list and checks each one to see if the user's name is in the message element. If so, it removes that element at the given index (starts at 0), which is the user name and timestamp for the message as well as the next element (now at the same index since the previous message was deleted), which is the actual message. It then increments the message count and when it gets the next message element, this will be the element already removed so it skips this by checking the count and if since it is not divisible by 2 with a remainder of 0, it increments the counter again. When checking the next element, it will again check to see if the user's name is in the element and if not, skips it by increment the index. In this manner it moves through the deque list for the channel messaging object in twos, removing matching elements for the user and skipping over object's for other users. It also counts all the elements removed and then divides it by two so it can give all the users an alert indicating the number of messages being removed. It does this by getting the new object list with all the user's messages removed. It then checks to see if it is empty and sets a flag so it can notify the users. The function creates a dictionary that includes the channel as well as an alert message that tells users the number of messages deleted for the indicated user and if the list is empty, an additional sentance indicating there are no messages currently for this channel. It also includes the new message list so it can update each user's page with the current message list that no longer includes the user messages for the user who chose to delete their messages. The dictionary is emitted to  'deleted messages' and broadcast=TRUE.

show_chans() web socketio which passes no data but simply triggers the function to emit the channel name array to 'channel names' with broadcast=FALSE.

show_msgs() web socketio which passes the channel to the function so that it can find the channel in the channel messaging object array and get all the messages for the given channel. It then puts the channel and the message list in a dictionary which is emits to 'channel messages' with broadcast=FALSE.

# layout.html
Template for main html page to display. Sets up title and links for html head. Sets up layout for html body, including card for entire page which is made up of one row which includes 2 rows with the first (card-one) which makes up the Fleck user info and channel list on the left and the second (card-two) which makes up the selected channel name and user messages on the right. Card-one and card-two each include a title block and text block. Only the card-one title block is fixed text and for all the other blocks, the content is controlled by javascript code as specified by the main page html. 

# index.html
File which defines the elements uses by the css and javascript files to control the display and layout of the main page for the web application. Content for the user name, channels, channel selection, channel title, messages, and all buttons are set up here. The file extends layout.html to define the text for the card-one block heading as well as the card-one block name dynamic content which includes user name field and channel info, if user name has been entered and saved in local storage, otherwise it includes a form to enter the user name and submit the selection via submit button. The channel info includes the following, once the user name is entered: display of the Channels heading as well as a form that displays all current channels created as radio button selections with a submit button for indicating a selection has been made. Regardless of any channels in the list or none, there is also a form to enter a new channel name and submitting the new name for channel creation (no button is displayed, but it will function since the input is defined in the html so it can be triggered in the javascript). The card-two block chan section is the header for the channel selection. It includes a card with one row and 3 colomns, one for the channel title text defined by the javascript, one for the channel name, and the last for a button which allows the user to delete all of their messages in this channel. The card-two block usermsg section includes the list of user messages for the channel, which is dynamically populated. It also includes a form for submitting new messages with a row and two columns, one for the textarea where the user enters their message and a second column for thesend button to submit the message once complete.

# sytlesMain.css
File sets up the default styling for the main page row font-family and different font-size plus background colors for card-one and card-two. This includes font-style, font-size, and margin-left for all headers, plus different colors for each header. The font-size, color, and background-color are also defined for the card-two message list and new message entry displays. The default font-style, size, and color as well as background-color are defined for the card-two channel titile and channel name displays. The color, margin-top, and margin-bottom are defined for the card-one buttons. The font-style and font-size are defined for the card-two buttons and the color, background-color, text-align, and margin-top defaults are defined for the delete button. The channel name label defaults are defined for margin-top, maring-left, and color as well as the background-color, border-color, font-style, and color defaults for the radio button and label combination are defined. The background-color for the card in card-two is also defined here.

# index.js
File defined in html to dynamically define values and content for web page based on data send and events defined. document.addEventListener('DOMContentLoaded', ()) first hides the channel selection and add channel name buttons. It then checks for the name value in local storage. If not found, it also hides the channel info title and channel name input field. If found, then it calls the displayName() function with the name from local storage to format card-one for a user. It then disables the name submit button and hides the card-two display fields and buttons. It finally defines the web socket for the document. The remaining functionality is included in the following event handlers and functions, defined within the function definition for document.addEventListener('DOMContentLoaded', ()):

socket.on('connect', ()) calls checkForChanSelection() function to display the channel name if stored, otherwise allow the user to select or create channels. It then disables the channel selection submit, message submit, and message delete all buttons and then defines the following event handlers: document.querySelector('#channel').onkeyup = () which disables the add channel name button until something is enetered. document.querySelector('#message').onkeyup = () which disables the add message button until something is entered. document.querySelector('#add-channel').onsubmit = () is triggered when the add channel name button is clicked and input is submitted. It gets the value in the channel name input field and clears the display input field. It also unhides the channel selection button since a channel has been added. It then emits the value entered to 'create channel' to trigger the python code to add the channel to the global arrays and emit it back via web socketio. document.querySelector('#add-message').onsubmit = () is triggered when the add message button is clicked. It gets the value in the message textarea as well as the name and channel from local storage. It then creates a dictionary for the channel, user name, and message, clears the display input field, and emits the dictionary to 'create message' to trigger the python code to add the message with user name to the global channel messaging object array for the specified channel and emit it back via web socketio. It also disables the add message button and enables the delete message button since messages now exist for this channel. document.querySelector('#msg-delete').onclick = () is triggered when the delete message button is clicked. It gets the name and channel from local storage. It then creates a dictionary for the channel and user name, disables the delete message button since no messages exist for this user to delete now, and emits the dictionary to 'delete message' to trigger the python code to remove the messages with user name from the global channel messaging object array for the specified channel and emit it back via web socketio. document.querySelector('#new-user').onsubmit = () is triggered when the add user name button is clicked and input is submitted. It gets the value from the user name input field and then sets the user name to the entered value in local storage. It then calls the displayName() function with the name entered to format card-one for a user. It also calls checkForChanSelection() function to show channels, in case there are some already created. 

checkForRadioButtons(channel) grabs all elements with the name 'selection' which means they are channel radio buttons. If any radio buttons for channel selection are defined, it checks each of them to see if they match the channel passed in. If so, then the 'checked' attribute is set to TRUE for that radio button match so it will display as selected.

checkForChanSelection() checks the channel value to see if it is saved in local storage. If channel value not found, then checks the name value to see if it is saved in local storage. If so, emits 'show channels' with no data to trigger the python code to emit the channel array back via web socketio. If channel name value found in local storage, then it calls checkForRadioButtons() with the value from local storage to mark the current selection as selected in case it is not 'checked' already. It then checks the name value to see if is saved in local storage and if so, emits the value from local storage to 'display all' to trigger the python code to emit the channel array back via web socketio.

showChannelInfo(data) grabs the div with the id 'new-channel' which is the container for the list of channel radio buttons as well as all elements with the name 'selection' which means they are channel radio buttons. It then gets the count of the elements with name 'selection' if there are any. It then loops through the array of channels passed in via data and for each channel, unhides the channel selection button, creates an input element of type 'radio', sets the name to 'selection', sets the id and value to the channel name in the array, creates a label for the input element, sets the labels innerHTML to the channel name in the array, and appends the input element and label to the 'new-channel' div if it is a newly created channel. If this is the first channel created AND the channel is saved in local storage, calls checkForChanSelection() to display the channel as selected (for users who are returning to the web site after closing their browser).

socket.on('show data', data) is triggered when python emits the channel array via web socketio. It then gets the current channel and array of all channels from the dictionary passed in data and if the user name is saved in local storage, it calls showChannelInfo() with the channel array, then calls displayChannel() with the current channel, and finally emits 'show messages' with current channel to trigger python code to emit the channel messaging object array back via web socketio. 

socket.on('channel messages', data) is triggered when python emits the channel message array via web socketio. It then checks to see if there is any data sent and if there is, it gets the current channel and array of all channel messages from the dictionary passed in data and if the channel name is saved in local storage, it calls displayTitle() with the current channel and then displayMessages() with the array of all channel messages. If no data is sent, then an alert is triggered indicating the channel was not found.

socket.on('deleted messages', data) is triggered when python emits the channel message array via web socketio. It then checks to see if there is any data sent and if there is, it gets the current channel, the alert text, and array of all channel messages from the dictionary passed in data and if the channel name is saved in local storage, it calls displayTitle() with the current channel, then displayMessages() with the array of all channel messages, and then an alert is triggered with the alert text sent. If no data is sent, then an alert is triggered indicating the message removal failed.

socket.on('channel names', data) is triggered when python emits the channel array via web socketio. It then checks to see if there is any data sent and if there is, if the user name is saved in local storage, it calls showChannelInfo() with the channel array. If no data is sent, then an alert is triggered indicating the channel already exists.

document.querySelector('#name').onkeyup = () which disables the add channel name button until something is enetered. 

document.querySelector('#new-user').onsubmit = () is triggered when the add user name button is clicked. It gets the value in the name input and saves it to local storage. It then calls displayName() with the value entered and checkForChanSelection() to show channels, in case there are some already created.

displayTitle(channel) gets the 'channel-title' display element by id and formats the text and styling. It then gets the 'channel-value' display element by id and formats the text with the channel passed in as well as the styling. It also unhides the message delete button.

displayMessages(selection, msg_list) gets the channel name saved in local storage and checks it against the selection passed in. If they match, then it gets the 'new-message' display element by id and calls removeMessages() with the selection to clear out the existing messages from the dipslay for the given channel. It then loops through the msg_list passed in and for each item in the array, creates a list item element, sets the id to 'user-message', appends a child node to the list item element containing result from document.createTextNode() call with the current array item, sets the innerHTML to the current array item, and if the the looping index is divisable by 2 evenly, sets the style to a different color since this is the user name and data timestamp info, then finally appends a child node to the 'new-message' display element containing the list item element.

displayName(name) formats the text with the user name passed in and then unhides the name and submit button display elements. It then grabs all elements with the name 'selection' which means they are channel radio buttons. If there are any channel radio buttons, then it enables the channel selection button for changing the channel selection. It also unhides the channel title and add channel button.

displayChannel(selection) unhides the messaging channel title display element and then sets the innerHTML with the messaging channel title text and the messaging channel value innerHTML with the selection passed in. It then unhides all of the following: change channel selection button, the whole card-two block, including the usermsg card, message delete all button, the channel messages list, the add message button, and the message input field.

removeMessages(selection) checks the selection passed in and if there is a value, it grabs the 'new-message' element by id and if there are messages in the list, loops through the list and for each item it removes the child node at childNode[0] in the list, until all display elements are removed.

document.querySelector('#change').onclick = () grabs all elements with the name 'selection' which means they are channel radio buttons. It then gets the value saved for the channel name in local storage. It calls removeMessages() with the channel name and then loops through the list of channel radio buttons and for each item it checks the 'checked' attribute and if TRUE, gets the value for the item, calls displayChannel() with the value, saves the new value as the channel name in local storage, and emits the new value to 'display all' to trigger the python code to emit the channel array back via web socketio.